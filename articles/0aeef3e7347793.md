---
title: "beforeEachは便利だけど注意点もあります。サンプルを添えて。"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["test", "unittest"]
published: false
---

皆さんはユニットテストを書かれていますか。私は書いています。

ユニットテストを何かしらのテスティングライブラリやフレームワークを使う場合、以下のようなことを言われたことがありませんか。

- 共通の前処理は `before` や `beforeEach` に書くと同じことを繰り返さずに済むよ
- 後処理も同様に `after` や `afterEach` に書くと良いよ

確かにこれらのセットアップ関数などはとても便利なのですが、一方でいくつか留意した方が良いポイントを含んでいると思います。

今回はサンプルコードを見つつ、以下のような内容についてお話したいと思います。

- `beforeEach` などの共通処理を行うことの留意点
- `beforeEach` にまとめないで良いと思う場合について（そして改善提案）
- 逆に `beforeEach` を使っても良いかなぁ。と思うケースについて

## サンプルコード

みなさんAWSは使ったことがありますか？

AWSにはたくさんの便利なサービスがありますが、一部のサービス名について間違えやすいものがあります。例えば、以下のようなサービス名です。

- Amazon EC2
- **AWS** Security Hub
    - `Amazon` ではなく `AWS` です
    - また `SecurityHub` ではなく `Security Hub` であることにも気をつけましょう
- Amazon **CloudFront**
    - こちらは `Amazon` ですね
    - また `Cloud Front` ではなく `CloudFront` です。こっちはスペースがはいりません。

このようにサービス名を間違えてしまいやすいので、以下のようなクラスを作って誤りに気付けるようにしてみましょう。

```ts
// AWS 名の typo に気づけるように作ってみたサンプルクラス
export class AwsServiceNameValidator {
  readonly prefix: string
  readonly serviceName: string

  // EC2 や S3 は Amazon から始まります。
  readonly prefixAmazon = new Set(["EC2", "S3"])
  // Security Hub や Lambda は AWS から始まります。
  readonly prefixAws = new Set(["Security Hub", "Lambda"])
  //  Security Hub はスペースが入ります。逆にCloudFrontはスペースが入りません。
  readonly invalidSpace = new Set(["SecurityHub", "Cloud Front"])

  constructor(prefix: string, serviceName: string) {
    this.prefix = prefix
    this.serviceName = serviceName
  }

  // Amazon はじまりなのか AWS はじまりなのかをチェック
  isValidPrefix(): boolean {
    // 本来 Amazon から始まるべきサービス名なのに AWS から始まっている場合はfalse
    if (this.prefixAmazon.has(this.serviceName) && this.prefix === "AWS") {
      return false
    }
    // 本来 AWS から始まるべきサービス名なのに Amazon から始まっている場合はfalse
    if (this.prefixAws.has(this.serviceName) && this.prefix === "Amazon") {
      return false
    }
    return true
  }

  // 間違えやすいスペースが入るのか、入らないのかをチェック
  // Cloud Front は余計なスペースが入っているのでfalse
  // SecurityHub は必要なスペースが入っていないのでfalse
  isValidSpace(): boolean {
    if (this.invalidSpace.has(this.serviceName)) {
      return false
    }
    return true
  }
}
```

さて、このクラスのテストをするのにあたってテストケースを考えてみましょう。

## ユニットテストを書く

### Step1: ベースとなるちょっと冗長なテストケース

まずは以下のようにテストケースを書いてみました。

```ts
import { AwsServiceNameValidator } from "./awsServiceNameValidator"

// 何回も同じ初期化を繰り返しているパターン
describe("AwsServiceNameValidator", () => {
  describe("isValid Prefix", () => {
    it("return true with prefix AWS and serviceName Security Hub", () => {
      // arrange
      const awsServiceNameValidator = new AwsServiceNameValidator(
        "AWS",
        "Security Hub"
      )

      // act
      const shouldTrue = awsServiceNameValidator.isValidPrefix()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })

  describe("isValid Space", () => {
    it("return true with serviceName Security Hub", () => {
      // arrange
      const awsServiceNameValidator = new AwsServiceNameValidator(
        "AWS",
        "Security Hub"
      )

      // act
      const shouldTrue = awsServiceNameValidator.isValidSpace()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })
})
```

他にテストケースが足りていないなど、言いたいことはありますが一旦こちらに書いてあるテストケースだけで考えてみましょう。

これらは `AWS SecurityHub` という入力に対して以下のようなテストを行っています。

- 接頭辞が `Amazon` ではなく `AWS` となっていて正しい
- `Security Hub` というようにちゃんと正しいスペースが入っている（`SecurityHub` ではない）

しかし、プログラマーであれば以下の部分について同じような初期化を何度もしているのが気になるかもしれません。

```ts
      const awsServiceNameValidator = new AwsServiceNameValidator(
        "AWS",
        "Security Hub"
      )
```

### Step2: beforeEachを使ってみたものの・・・

`そうだ！同じような前処理はセットアップ関数にまとめれば良いって聞いたことがある！` ということで以下のようなコードを書いてみたくなるかもしれません。

```ts
// 次にbeforeEachを使っているパターン
// 一見スッキリして良さそうだけど・・・
describe("AwsServiceNameValidator", () => {
  let awsServiceNameValidator: AwsServiceNameValidator

  beforeEach(() => {
    // 共通化して前処理もセットアップ関数にまとめてスッキリ
    // と思うじゃん？
    awsServiceNameValidator = new AwsServiceNameValidator("AWS", "Security Hub")
  })

  describe("isValid Prefix", () => {
    it("return true with prefix AWS and serviceName Security Hub", () => {
      // act
      const shouldTrue = awsServiceNameValidator.isValidPrefix()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })

  describe("isValid Space", () => {
    it("return true with serviceName Security Hub", () => {
      // act
      const shouldTrue = awsServiceNameValidator.isValidSpace()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })
})
```

一見するとスッキリしていて良さそうですが、このテストケースには以下のような点に気をつける必要があります。

- `awsServiceNameValidator` という変数をテストケースの間で共有している
  - 一方のテストケースの条件を変更したい場合、他方のテストケースに影響が出てしまう
    - 今回はたった2個しかないのでまだ良いですが、他にもテストケースが増えると、それだけ状態を共有してしまう
- 確かに「同じコードを繰り返していた」を解消できた気がするけど、そもそもこの初期化処理は共通処理としてまとめるべきなのか
  - 2つのテストケースで確かめたかった関心事は全然別物のはず
    - サービスの接頭辞が正しいか
    - サービス名に正しい形でスペースが入っているか
  - 確かに「同じコード」を使っていたけど、それは本当にDRYなのか
    - 参考: https://x.com/t_wada/status/1798569809745166616
- スクロールしないと `beforeEach` がどのような初期化を行っているのかがわからない
  - 安易にセットアップ関数でまとめると、下の方のテストケースでは結構上にスクロールしないと `awsServiceNameValidator` がどのような初期化を行っているのかわからない
    - 後でテストを追加したり変更する人でもぱっと見てわかりやすい方が良い
  - 以下の画像のような状態（今回は2つだけですが他にも沢山テストケースがあると、後のテストでは沢山スクロールしないと初期化の条件が見えない）

![上にスクロールしないと初期化の条件が見えない](/images/unittest-before/scroll-needed.jpg)

良いユニットテストの条件には「テストケース間が独立していて、どんな順番で実行されても良い」というものがあると考えています。

セットアップ関数はとても便利な反面、ある種テストケース間で状態を共有してしまい、テストケース間の独立性を損なう可能性があると思います。

ということで、次のようにテストを書いてみました。

### Step3: ヘルパー関数を使ってみる

```ts
// ヘルパー関数
// クラスに修正が入ってもここだけ直せばいいし、テストケースの中身が見やすい
// 引数を省略してデフォルトの引数で初期化したインスタンスを返すのもよいかも
const makeAwsServiceNameValidator = (
  args: ValidatorArgs
): AwsServiceNameValidator => {
  return new AwsServiceNameValidator(args.prefix, args.serviceName)
}

describe("AwsServiceNameValidator", () => {
  describe("isValid Prefix", () => {
    it("return true with prefix AWS and serviceName Security Hub", () => {
      // arrange
      const awsServiceNameValidator = makeAwsServiceNameValidator({
        prefix: "AWS",
        serviceName: "Security Hub",
      })

      // act
      const shouldTrue = awsServiceNameValidator.isValidPrefix()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })

  describe("isValid Space", () => {
    it("return true with serviceName Security Hub", () => {
      // arrange
      const awsServiceNameValidator = makeAwsServiceNameValidator({
        prefix: "AWS",
        serviceName: "Security Hub",
      })

      // act
      const shouldTrue = awsServiceNameValidator.isValidSpace()

      // assert
      expect(shouldTrue).toBeTruthy()
    })
  })
})
```

一見すると、一番最初のコードと変わらないように見えますが、以下のような利点があります。

- `AwsServiceNameValidator` に変更が入っても `makeAwsServiceNameValidator` だけを修正すれば良い
- `beforeEach` で共有していた状態をテストケース間で共有せずに済む
- テストが大きくなってきても、テストケースの中を見るだけでどのようなテストが行われているかがわかる

このテクニックや考え方は以下の書籍で作者の `Roy Osherove` さんが提唱されていました。

https://www.manning.com/books/the-art-of-unit-testing-third-edition

また、以下のような記事でも同様の内容を紹介されていますので、興味がある方はぜひ読んでみてください。

https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices

## 逆にセットアップ関数などを使っても良いのでは？という場合

**DBなどの外部の依存の状態に左右される場合** が主に該当すると思います。

一般的なWebシステムにおいては「DBを取り扱うクラス（モデルやリポジトリ）」があったり、DBに依存するようなテストを書くことがあります。

すべてをフェイク（モック、スタブ）を駆使してユニットテストで書くよりも、コンテナ仮想化技術などで立ち上げたDBを使って、よりアプリの信頼度を高めたテストも書きますよね。（これはユニットテストというよりも統合テストにあたるのかもしれませんが）

そのような場合、以下のような前処理・後処理のために `beforeEach` や `afterEach` を使うのも良いと思います。

```ts
describe("createBlogPost", () => {
    beforeEach(() => {
        createDummyUser()
    })
    
    afterEach(() => {
        rollBackTransaction()
    })
    
    it("return created blog post", () => {
        // arrange
        const blogPostData = {
            title: "Hello, World!",
            content: "This is my first blog post!",
            user: "dummyUser"
        }
        
        // act
        const createdBlogPost = createBlogPost(blogPostData)
        
        // assert
        expect(createdBlogPost.title).toEqual(blogPost.title)
    })
})
```

今回はわかりやすい関数を使っていますが、実際のテストでは「DBのトランザクションを使って、いい感じにロールバックする」といった処理を行うことがあると思います。

https://dev.classmethod.jp/articles/prisma-jest-isolated-transaction/

このように「どうやってもテストケース間で共有する必要のある外部の依存」については、セットアップ関数などを利用するのも良いかもしれません。

とはいえ、極力ユニットテストをしやすくなるように直接DBをやORMと関わるのは一部の関数やクラスだけにして、ビジネスロジックとDBの都合との分離は意識したいところですね。（DBにかかわらず、外部への依存を極力減らすことがテストしやすいコードになると思います）

## まとめ

- `beforeEach` などのセットアップ関数の利用には注意が必要
  - テストケース間で思わず状態を共有してしまう可能性があるなど
- そんなときにはヘルパー関数を用意してみると良いかも
  - 参考書籍: https://www.manning.com/books/the-art-of-unit-testing-third-edition
- ただしDBなどが絡む統合テストの場合にはむしろセットアップ関数を使っても良いかもしれません

以上、ユニットテストについて細かい話をしてみました。今後もテストに関する記事を書いてきたいと思います。

最後まで読んでいただき、ありがとうございました！

